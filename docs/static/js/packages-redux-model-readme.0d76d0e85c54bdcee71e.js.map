{"version":3,"sources":["/Users/yangqianjun/Documents/project/e-kit/ekit/packages/redux-model/README.mdx"],"names":["layoutProps","MDXContent","components","props","mdxType","parentName","isMDXComponent"],"mappings":"mXASMA,EAAc,GAIL,SAASC,EAAT,GAGX,IAFFC,EAEC,EAFDA,WACGC,EACF,8BACD,OAAO,YALS,UAKT,iBAAeH,EAAiBG,EAAhC,CAAuCD,WAAYA,EAAYE,QAAQ,cAC5E,iBAAQ,CACN,GAAM,eADR,eAGA,yEACA,uBAAK,kCAAMC,WAAW,OAAU,IAA3B,iCAEL,iBAAQ,CACN,GAAM,MADR,MAGA,8MACA,iBAAQ,CACN,GAAM,kBADR,kBAGA,uBAAK,kCAAMA,WAAW,OAAU,CAC5B,UAAa,gBADZ,wXAoBL,iBAAQ,CACN,GAAM,WADR,WAGA,8NACA,+EACA,uBAAK,kCAAMA,WAAW,OAAU,CAC5B,UAAa,gBADZ,+GAQL,iBAAQ,CACN,GAAM,aADR,aAGA,2GACA,iBAAQ,CACN,GAAM,iBADR,kBAGA,yIACA,+RACA,uBAAK,kCAAMA,WAAW,OAAU,CAC5B,UAAa,gBADZ,6WAcL,iBAAQ,CACN,GAAM,iBADR,iBAGA,oYACA,uBAAK,kCAAMA,WAAW,OAAU,CAC5B,UAAa,gBADZ,2uBAwBL,+KACA,uBAAK,kCAAMA,WAAW,OAAU,CAC5B,UAAa,gBADZ,6CAML,iBAAQ,CACN,GAAM,gBADR,gBAGA,uBAAK,kCAAMA,WAAW,OAAU,CAC5B,UAAa,gBADZ,owBAuBL,iBAAQ,CACN,GAAM,yBADR,yBAGA,sIACA,0EACA,uBAAK,kCAAMA,WAAW,OAAU,CAC5B,UAAa,gBADZ,2NAOL,wCACA,uBAAK,kCAAMA,WAAW,OAAU,CAC5B,UAAa,iBADZ,0MAcL,iBAAQ,CACN,GAAM,0BADR,2BAGA,kMACA,uSACA,uBAAK,kCAAMA,WAAW,OAAU,CAC5B,UAAa,gBADZ,sxB,qLAmCTJ,EAAWK,gBAAiB","file":"static/js/packages-redux-model-readme.48358830.js","sourcesContent":["\nimport React from 'react'\nimport { mdx } from '@mdx-js/react'\n\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\n\n\nconst layoutProps = {\n  \n};\nconst MDXLayout = \"wrapper\"\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n    <h1 {...{\n      \"id\": \"redux-model\"\n    }}>{`Redux Model`}</h1>\n    <p>{`Tkit 全局 Redux Model 封装。`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`npm i -S @ekit/redux-model\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"cm\"\n    }}>{`CM`}</h2>\n    <p>{`通过 CM 创建集成 Immer 的全局 Redux Model。通过 createModel 创建未集成 Immer 的全局 Redux Model。`}</p>\n    <h2 {...{\n      \"id\": \"--示例\"\n    }}>{`- 示例`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`import createModel, { Tction, CM } from '@ekit/redux-model';\n\nexport const userModelState = {\n  name: ''\n};\n\nexport const UserModel = CM({\n  state: userModelState,\n  namespace: 'cmModel',\n  reducers: {\n    /** 写入名字 */\n    doSetName: (state, action: Tction<string>) => {\n      state.name = action.payload;\n    }\n  },\n  effects: {}\n});\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"--state\"\n    }}>{`- State`}</h2>\n    <p>{`通过 Tkit Cli 创建 Model 时会自动将 Model State、Actions、Reducers、Sagas 注入到 Feature 响应的入口文件。`}</p>\n    <p>{`比如，State 入口文件：`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`import { userModelState } from './userModel';\n\nconst initialState = {\n  userModel: userModelState\n};\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"--effects\"\n    }}>{`- Effects`}</h2>\n    <p>{`通过 Model 的 effects 属性定义副作用。`}</p>\n    <h2 {...{\n      \"id\": \"---tput-tcall\"\n    }}>{`-- tPut, tCall`}</h2>\n    <p>{`使用 TypeSafe tPut、tNBPut、tCall 替代 Redux Saga 原生的 put、call。`}</p>\n    <p>{`tPut 是阻塞的，会等到触发 action 结束后，再进入下一步；tNBPut 是非阻塞的，不会等待被触发 action 执行完毕。`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`  import { TkitUtils as Utils } from '@ekit/types';\n\n  const model = CM({\n    effects: {\n      *doXX({ tPut, tCall }): Iterator<{}, any, any> {\n        yield tCall(effect, args: typed)\n        const data: Utils.GetReturnTypeOfAsyncFun<typeof effect> = yield tCall(effect, args);\n        yield tPut(model.action.doYY, args: typed)\n      }\n    }\n  })\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"---with-async\"\n    }}>{`-- With Async`}</h2>\n    <p>{`Tkit Redux Model 实现了友好的控制副作用开始、成功、失败交互效果的协议。结合 @ekit/async 一起使用，控制全局的 Loading 效果、提示信息，提升开发效率。`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`{\n  effects: {\n    /** 显示全局的loading效果 */\n    doSomethingWithLoading: [\n      function*({ tPut, tCall }, action: Tction<{ id: string }>): Iterator<{}, any, any> {\n        /** 抛出全局错误信息 */\n        throw '操作失败';\n        /** 抛出全局成功信息 */\n        return '操作成功';\n      },\n      {\n        type: 'takeEvery', // it all depends\n        loading: true\n      }\n    ],\n    *doSomethingAsync({ tPut, tCall }, action: Tction<{ id: string }>): Iterator<{}, any, any> {\n      /**  抛出全局错误信息 */\n      throw '操作失败';\n    }\n  }\n}\n`}</code></pre>\n    <p>{`所有来自 Tkit Redux Model 的 Effects，在传递给 @ekit/async 的 Payload 内添加标识：`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`{\n  channel: '@ekit/model/effect';\n}\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"示例\"\n    }}>{`示例`}</h3>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`import { CM, Tction }  from '@ekit/redux-model';\nimport otherModel from './otherModel';\n\nconst myModel = CM({\n  effects: *doSomethingAsync({ namespace, put, tPut }, action: Tction<{ username: string }>) {\n    // 触发其他 model action\n    // way 1, rec\n    yield tPut(otherModel.actions.actionsNameA, { username: '' });\n    // way 2\n    yield put({ type: otherModel.TYPES.actionsNameA, payload: { username: '' } });\n\n    // 出发本 model action\n    // way 1, rec\n    yield tPut(myModel.actions.actionsNameA, { username: '' });\n    // way 2\n    yield put({ type: myModel.TYPES.actionsNameA, payload: { username: '' } });\n    // way 3\n    yield put({ type: \\`\\${namespace}/actionsNameA\\`, payload: { username: '' } });\n  }\n})\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"--promisified-actions\"\n    }}>{`- Promisified Actions`}</h2>\n    <p>{`Tkit Redux Model 支持 Effects 派生 Actions 被触发时返回 Promise。`}</p>\n    <p>{`配置 Redux Store 中间件：`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`import { promiseMiddleware } from '@ekit/model';\n\n// 在 sagaMiddleware 前添加 promiseMiddleware\nconst middlewares: Middleware[] = [promiseMiddleware, sagaMiddleware, routerMiddleware(history)];\n`}</code></pre>\n    <p>{`Connected：`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-tsx\"\n      }}>{`<div\n  className=\"k-layout-header\"\n  onClick={async () => {\n    try {\n      const res = await props.actions.doUserInfo();\n      console.log(res);\n    } catch (e) {}\n  }}\n>\n  test\n</div>\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"--async--await-effects\"\n    }}>{`- Async & Await Effects`}</h2>\n    <p>{`Tkit Redux Model 支持 Async 和 Generator 混用，在 Async Effect 内只能使用 asyncSelect、asyncPut、asyncNBPut。`}</p>\n    <p>{`asyncPut 是阻塞的，会等到触发 action 结束后，再进入下一步；asyncNBPut 是非阻塞的，不会等待被触发 action 执行完毕。`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`{\n  effects: {\n    doUserInfo: [\n      function*({ tCall, tPut, select }): Iterator<{}, UserInfoResult | undefined, any> {\n        // 使用 select, tPut, tCall\n        const userInfo = yield select(selectUserInfo);\n        return userInfo;\n      },\n      {\n        type: 'takeLatest'\n      }\n    ],\n    async doAjax({ asyncSelect, asyncPut }) {\n      // 必须使用 asyncSelect asyncPut\n      const lastUserInfo = await asyncSelect(selectUserInfo);\n      const userInfo = await asyncPut(model.actions.doUserInfo);\n      return new Promise<number>(rs => setTimeout(() => rs(1), 500));\n    },\n    doHaha: [\n      async () => {\n        return Promise.resolve({ name: 200 });\n      },\n      {\n        type: 'takeLatest'\n      }\n    ]\n  }\n}\n`}</code></pre>\n    </MDXLayout>;\n}\n\n;\nMDXContent.isMDXComponent = true;"],"sourceRoot":""}